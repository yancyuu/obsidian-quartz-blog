# 6、索引类型/索引结构

Owner: yancy yu
Tags: mysql

<aside>
❓ **问题1：如果int类型数据用字符串类型查询是否走索引**
走索引
**问题2：如果字符串类型数据用int查询是否走索引**
不走索引

</aside>

<aside>
✅ 前者，在数据库查询中，优化器的任务是找出最高效的执行计划。对于`INT`字段和字符串常量之间的比较，优化器知道这个操作涉及到明确且可预测的类型转换：它只需要把字符串转换为整数即可。这个转换可以在生成查询计划之前就完成，因为它是一次性的操作，并且不依赖于表中的任何数据。因此，优化器可以预先进行这个转换，并据此使用索引。

这种早期转换有几个优势：

1. **简单性**：字符串到整数的转换是明确的，不依赖于其他行或字段。
2. **效率**：因为转换只需要做一次，它不会影响查询的总体性能。
3. **索引可用性**：早期转换允许优化器使用已有的整数索引，而不需要动态地在每一行上进行转换。

在这种情况下，因为类型转换是确定的并且易于执行，所以优化器可以在查询计划生成之前就完成它，从而更有效地利用索引。

这与用整数去查询字符串字段的情况不同。在后者的场景中，整数必须被转换为字符串，并且这个转换通常需要在每一行上都执行一次，因为字符串字段可能包含各种不同类型的数据（如文本、特殊字符等）。这就增加了查询的复杂性，并可能导致索引失效。

</aside>

<aside>
❓ 对于第二种情况，先对整数类型去做字符串类型的转化，再去查不是更快吗？

</aside>

<aside>
✅ 在使用整数查询字符串字段的场合，预先将整数转为字符串确实是一个合理的想法。但这个操作通常需要由应用程序或者查询语句本身来完成，而不是数据库优化器。数据库优化器通常会尊重字段的原始数据类型和查询中提供的数据类型。

例如，如果你有一个名为`username`的`VARCHAR`字段，并想找到所有`username = 123`的记录，那么最佳做法是在查询中明确使用字符串：

```sql
SELECT * FROM users WHERE username = '123';
```

这样，数据库优化器就能够利用可能存在于`username`字段上的索引。

然而，在一些情况下，数据库可能不会自动完成这种优化：

1. **转换复杂性**：字符串字段可能有多种用途，包括存储文本、数字或混合类型。数据库优化器不会假设所有数据都是纯数字。
2. **字符集和排序规则**：字符串的比较可能涉及字符集和排序规则，这会增加额外的复杂性。
3. **统一行为和预测性**：数据库通常会遵循一致的行为模式，以便开发人员能准确地预测查询的结果。如果优化器随意更改数据类型，可能会导致不一致或不可预测的行为。

总之，虽然预先将整数转换为字符串听起来像一个合理的优化，但这通常需要在应用层或查询层完成。如果你知道一个字段应该包含数字，最好是在查询中明确地使用正确的数据类型，以便最大限度地利用索引。

</aside>

> - explain select * from student where abs(age) =18;
这个查询中使用了**`abs()`**函数，通常情况下这会导致索引失效。因为你对**`age`**列进行了函数处理，数据库不能直接用索引查找，而必须遍历每一行来计算**`abs(age)`**。
- explain select * from student where name like'%name%' ;
如果**`name`**字段前面有百分号（**`%`**），则通常也不会使用索引，因为这会触发全表扫描以查找匹配的字符串。
- explain select * from student where name ='name' or age = 18;
这种情况比较特殊。假设**`name`**和**`age`**都有索引，MySQL可能会分别对**`name`**和**`age`**使用索引，然后再合并结果。但这依赖于多种因素，如表的大小、数据分布等。有时，MySQL可能选择其中一个条件进行索引搜索，然后再用另一个条件进行过滤。
> 

<aside>
❓ Mysql在InnoDB引擎下，非唯一索引如果出现重复键，底层B+树具体是怎么排列的呢？

</aside>

<aside>
✅ 在InnoDB存储引擎中，非唯一索引（Secondary Index）对于重复键值的处理与唯一索引（Primary Index、Unique Index）有所不同。对于非唯一索引，如果有多个行拥有相同的键值，InnoDB会将这些行放到相同的B+树节点中。不过，这里有一点很重要：即使是非唯一索引，InnoDB也会在内部尝试使每个索引项变得唯一。

这是通过在每个非唯一索引键值后面附加一个唯一标识符来实现的，通常是主键的值。这样，即使两行有相同的索引键，它们在B+树中也会因为附加了主键值而变得唯一。

假设我们有一个简单的表：

```sql
CREATE TABLE books (
    id INT PRIMARY KEY,
    title VARCHAR(50),
    INDEX(title)
);

```

并插入几条记录：

```sql
INSERT INTO books (id, title) VALUES (1, 'Python');
INSERT INTO books (id, title) VALUES (2, 'Python');
INSERT INTO books (id, title) VALUES (3, 'Java');

```

在这个例子中，`title`字段有一个非唯一索引。由于第一和第二条记录的`title`都是"Python"，它们会被存储在B+树中的相近位置。但是由于InnoDB会在`title`值后面附加`id`值（主键），因此在B+树内部，这两个键实际上是不同的。具体的存储可能类似于：

- "Java" + 3
- "Python" + 1
- "Python" + 2

这样，即使索引键值相同，由于附加了主键，它们在B+树中也会被认为是不同的节点。这也是InnoDB能高效执行范围查询和JOIN操作的一个原因。

</aside>

## 一条sql在mysql的执行过程

### 查询SQL执行流程：

1. **权限校验（连接器）**:
    - 首先进行用户认证，确认用户名和密码。
    - 验证该用户是否有权执行特定的SQL查询。
2. **查询缓存**:
    - MySQL会检查查询缓存是否有这个SQL语句的结果。
    - （注：这一步在MySQL 8.0以后被废弃）
3. **分析器**:
    - 词法分析：将SQL语句分解为“令牌”（tokens），例如关键字、表名、列名等。
    - 语法分析：校验SQL语句的语法是否正确。
4. **优化器**:
    - 选择最佳的执行计划，比如选择索引，决定连接的顺序等。
5. **执行器**:
    - 检查行级权限。
    - 调用存储引擎的API来执行查询。
6. **引擎**:
    - InnoDB等存储引擎真正地执行查询并返回结果。

### 更新SQL执行流程：

1. **分析器**:
    - 词法和语法分析，与查询流程相同。
2. **权限校验**:
    - 检查用户是否有执行更新操作（如INSERT, UPDATE, DELETE）的权限。
3. **执行器**:
    - 检查行级权限。
    - 执行预处理，如锁定表或行。
4. **引擎**:
    - 执行实际的数据更新。
5. [**Redo Log Prepare**](mysql日志.md):
    - 写入预提交（prepare）状态的redo log。
6. **Binary Log (binlog)**:
    - 将此次更新操作写入到二进制日志中。这是MySQL主从复制和数据恢复的重要组成部分。
7. **Redo Log Commit**:
    - 提交redo log，完成数据更新。

## 索引结构

## **为什么innoDB索引用B+树？**

在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。

![Untitled](Untitled.jpeg)

**聚簇索引优缺点：**

优点：

1.按主键查找速度非常快

3.辅助索引使用主键作为指针而不是地址作为指针，当数据修改树结构发生变化时，主键B+树无论怎么变，辅助索引都不会受影响

4.排序和范围查找有优势

缺点：

2.索引存储开销大，叶子节点需要存储所有数据和索引

1.辅助索引要查找两次，先找到主键再找到数据

**innoDB索引和MyISAM索引的异同？**

1.InnoDB的数据文件本身就是主索引文件，而MyISAM的主索引和数据是分开的，索引文件仅保存数据记录的地址。

2.InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引结构相同。

3.InnoDB是聚簇索引，叶子节点聚集了所有索引和数据，且数据存储在对应索引下面。

4,MyISAM查询效率比innodb高

## **为什么要使用索引：（B数是顺序存储的）**

- 索引大大减少了存储引擎需要扫描的数据量
- 索引可以帮助我们进行排序以避免使用临时表
- 索引可以吧随机IO变成顺序IO

### **索引是不是越多越好**

- 索引会增加写操作的成本（写入时需要维护索引信息
- 太多的索引会增加查询优化器的选择时间（查询优化器会选择合适的索引

## 索引类型及其特点

### 1. **B-tree索引特点：**

- B-tree是以B+树的结构存储数据的:子节点信息是存在父节点指针中
- B-tree索引能够加快数据的查询速度
- B-tree索引更适合进行范围查找

### **什么情况下使用B-tree索引：按顺序存储**

- 全值匹配的查询
    
    order_sn='3231313'
    
- 匹配最左前缀的查询(联合索引)：只要一个联合索引的第一列符合查询条件
- 匹配列前缀：可以匹配某一列的开头部分****
    
    order_sn like '3231313%'
    
- 匹配范围值的查询
- 精确匹配左前列并范围匹配另外一列(联合索引)
- 只访问索引的查询(覆盖索引)

### **B-tree索引的所用限制：**

- 如果不是按照索引最左列开始查找，则无法使用索引(联合索引)
- 使用索引时不能跳过索引中得列
- not in 和 <> 操作无法使用索引
- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引 ( 联合索引abc where a = ‘’ and b> 3 and c=7 只有a被用到）

### 2. **聚集索引和非聚集索引**

- 聚集索引B+Tree存储的是索引数据以及这一列的数据，而非聚集索引就是在叶子节点存储的是当前数据数据的磁盘地址，需要通过磁盘地址去磁盘上面取得数据。

### 3. **联合索引**

- 就是通过几个查询条件建立出来的索引

### 4. **Hash索引特点**

**Hash索引特点（INNODB自行建立的又称自适应hash索引）：hash中存着键值，hash码和对应的行的指针**

- Hash索引是基于Hash表实现的，只有查询条件精确匹配

Hash索引中的所有列时，才能够使用hash索引（也就是说hash索引只能用于等值查询中

- 对于hash索引中得所有列，存储引擎都会为每一行计算一个Hash码，Hash索引中存储的就是hash码。

### **Hash索引的所用限制：**

- 如果不是按照索引最左列开始查找，则无法使用索引(联合索引)
- 因为hash索引只存了hash码和对应数据的指针，所以hash素有必须进行二次查找
- Hash索引无法进行排序（只能进行全键值的匹配查找
- 同上，Hash索引不支持部分索引查找也不支持范围查找
- Hash索引中Hash码计算可能存在Hash冲突

## 索引优化策略(mysql内部优化)

1. 索引列上不能使用表达式和函数（where条件后的索引列不能使用
2. 前缀索引和索引列的选择性
- INNODB中得B数索引对于键值的大小有限制，最大为767个字节
- 当对很大长度的列建立索引：mysql支持前缀索引和索引列的选择性
    - 前缀索引：去了字符串的一部分作为键值，所以选择性必然会降低
    - 索引的选择性是不重复的索引值和表的记录数的比值

3. 联合索引

- 如何选择索引引列的顺序
    - 经常会被使用到的列优先
    - 选择性高的列优先
    - 宽度小的列优先

4.覆盖索引：索引已经“覆盖了”我们的查询需求

核心就是只从辅助索引要数据。普通索引(单字段)和联合索引,以及唯一索引都能实现覆盖索引的作用

组合索引查询方式：非聚集索引在B+树上定位索引 ，再利用聚集索引来定位到数据行。

优点：

- 可以优化缓存，减少磁盘IO操作
- 可以减少随机IO，变随机IO变为顺序IO操作
- 可以避免对Innodb主键索引的二次查询
- 可以避免MyISAM表进行系统调用

缺陷：

- 无法使用覆盖索引的情况
- 存储引擎不支持覆盖索引
- 查询中使用了很多列
- 使用双%号的like查询

## 索引优化策略(存储引擎层)

### 1. 使用索引扫描来优化排序

- 通过排序操作
- 按照索引顺序扫描数据

要求

- 索引的列顺序和Order By子句的顺序完全一致
- 索引中所有列的方向（升序，降序）和order by子句完全一致
- Order By中得字段全部在关联表中的第一张表

不是很容易使用：一般很多情况，查询的字段是一个范围，而且索引建立的时候也没有规定排序。

2.模拟Hash索引优化查询

- 只能处理键值的全值匹配查找
- 所使用得Hash函数决定着索引的值。

索引可以减少锁定的行数：可以优化异步排他锁（悲观锁）阻塞的情况。

索引可以加快处理速度，同时也加快了锁的释放。

### 2. 利用索引来优化锁

索引可以减少锁定的行数：可以优化异步排他锁（悲观锁）阻塞的情况。

索引可以加快处理速度，同时也加快了锁的释放。

### 3. 索引的维护和优化

- 删除重复的索引和冗余的索引
1. primary key(id),unique key(id),index(id) //重复
2. index(a)，index(a,b) //冗余
3. primary key(id),index(a,id) //冗余 id作为联合索引，如果很大不如单列索引
- 查找未使用的过的索引
- 更新索引统计信息以及减少索引碎片
    - analyze table table_name：统计信息存在磁盘中，innode不会存在磁盘中，而是随机扫描存在内存中，所以效率高
    - optimize table table_name：使用不当会导致锁表
    

## 以下情况会命中索引

在MySQL数据库中，索引的使用能大大提高查询性能。下面是几个可能命中索引的SQL查询例子：

假设我们有一个名为`students`的表，包含字段：`id`（主键）、`name`、`age`和`grade`。

1. **等值查找**
    
    ```sql
    SELECT * FROM students WHERE id = 5;
    
    ```
    
    如果`id`字段有一个主键或唯一索引，这个查询会命中索引。
    
2. **范围查找**
    
    ```sql
    SELECT * FROM students WHERE age BETWEEN 20 AND 25;
    
    ```
    
    如果`age`字段有索引，这个查询会使用该索引进行范围查找。
    
3. **LIKE操作符（前缀匹配）**
    
    ```sql
    SELECT * FROM students WHERE name LIKE 'John%';
    
    ```
    
    如果`name`字段有索引，并且LIKE操作符的模式是前缀常量（即"%"出现在末尾），则会使用索引。
    
4. **多列索引（联合索引）**
    
    ```sql
    SELECT * FROM students WHERE age = 22 AND grade = 'A';
    
    ```
    
    如果有一个多列索引包含`age`和`grade`，或者有单独索引分别覆盖`age`和`grade`，这个查询可能会使用这些索引。
    
5. **ORDER BY和LIMIT**
    
    ```sql
    SELECT * FROM students ORDER BY age LIMIT 10;
    
    ```
    
    如果`age`字段有索引，那么这个排序和限制结果集的操作也会使用索引。
    
6. **IN操作符**
    
    ```sql
    SELECT * FROM students WHERE id IN (3, 4, 5);
    
    ```
    
    如果`id`字段有索引，使用IN操作符的这种查找也会命中索引。
    

## 以下情况不会命中索引

在MySQL中，有一些情况下索引可能不会被使用，即使字段上存在索引。以下是一些不命中索引的查询例子：

假设我们仍然使用上面的`students`表，该表包含字段：`id`（主键）、`name`、`age`和`grade`。

1. **使用了NOT操作符**
    
    ```sql
    SELECT * FROM students WHERE NOT (id = 5);
    
    ```
    
    NOT操作符通常会导致全表扫描。
    
2. **LIKE操作符（非前缀匹配）**
    
    ```sql
    SELECT * FROM students WHERE name LIKE '%John%';
    
    ```
    
    如果LIKE操作符的模式不是以前缀开始，索引一般不会被使用。
    
3. **使用了函数或表达式**
    
    ```sql
    SELECT * FROM students WHERE YEAR(birthday) = 1990;
    
    ```
    
    对字段应用函数会导致索引失效。
    
4. **使用OR连接的多条件**
    
    ```sql
    SELECT * FROM students WHERE id = 5 OR age = 20;
    
    ```
    
    如果OR两边的条件字段都有索引，MySQL一般不会同时使用这两个索引。
    
5. **非最左前缀**
    
    ```sql
    SELECT * FROM students WHERE grade = 'A';
    
    ```
    
    假设有一个联合索引`(age, grade)`，因为查询没有涉及到最左侧的`age`字段，所以这个索引可能不会被使用。
    
6. **索引的选择性差**
    
    ```sql
    SELECT * FROM students WHERE age >= 10;
    
    ```
    
    如果`age`字段上的值几乎都大于或等于10，那么即使存在索引，MySQL也可能选择进行全表扫描。
    
7. **小表**
    
    对于非常小的表，全表扫描有时候比使用索引更快。
    
8. **NULL值**
    
    ```sql
    SELECT * FROM students WHERE age IS NULL;
    
    ```
    
    一般情况下，MySQL不会为包含NULL值的列使用索引。
    

请注意，是否使用索引还取决于查询优化器，它会基于统计信息和其他因素做决策。你可以使用`EXPLAIN`命令来查看查询计划，进一步了解是否使用了索引。