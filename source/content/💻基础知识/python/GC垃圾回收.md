

<aside>
🌟 现在的⾼级语⾔如java，c#等，都采⽤了垃圾收集机制，⽽不再是c，c++⾥

⽤户⾃⼰管理维护内存的⽅式。⾃⼰管理内存极其⾃由，可以任意申请内存，但如同⼀把双刃剑，为⼤量内存泄露，悬空指针等bug埋下隐患。 对于⼀个字符串、列表、类甚⾄数值都是对象，且定位简单易⽤的语⾔，⾃然不会让⽤户去处理如何分配回收内存的问题。 python⾥也同java⼀样采⽤了垃圾收集机制，不过不⼀样的是: python采⽤的是引⽤计数机制为主，标记-清除和分代收集两种机制为辅的策略

- 引⽤计数机制为主
- 隔代清除为辅

**如果你重写了__del__方法，并且没有调用父类的del方法，会造成这个对象清理不掉。**

</aside>

**引⽤计数机制的优点：**

- 简单
- 实时性：⼀旦没有引⽤，内存就直接释放了。不⽤像其他机制等到特定时机。实时性还带来⼀个好处：处理回收内存的时间分摊到了平时。

**引⽤计数机制的缺点：**

- 维护引⽤计数消耗资源循环引⽤
- list1与list2相互引⽤，如果不存在其他对象对它们的引⽤，list1与list2的引⽤计数也仍然为1，所占⽤的内存永远⽆法被回收，这将是致命的。 对于如今的强⼤硬件，缺点1尚可接受，但是循环引⽤导致内存泄露，注定python还将引⼊新的回收机制。(标记清除和分代收集)

**隔代清除原理**

⼀个链表(free list)来持续追踪未使⽤的、⾃由的对象⼀样，Python使⽤⼀种不同的链表来持续追踪活跃的对象。⽽不将其称之为“活跃列表”，Python的内部C代码将其称为零代(Generation Zero)。每次当你创建⼀个对象或其他什么值的时候，Python会将其加⼊零代链表。然后**定时清理**。

从上边可以看到当我们创建新的ABC节点的时候，Python将其加⼊零代链表。请注意到这并不是⼀个真正的列表，并不能直接在你的代码中访问，事实上这个链表是⼀个完全内部的Python运⾏时。

**如何触发垃圾回收机制：**

1. 调⽤gc.collect(),
2. 当gc模块的计数器达到阀值的时候。
3. 程序退出的时候