> 目标是分享我们如何从单个Agent走向系统化、多智能体协同治理的演进路径，尤其聚焦我们在订餐、问答、陪练智能体中的真实工程实践。

---

## 一、引子：从订餐Agent出发

我们从最早的订餐智能体入手，逐步构建了多个任务导向型Agent，包括：

- 订餐Agent：主打推荐与意图识别、购物车逻辑
    
- 问答Agent：接入结构化+向量知识库（RAG）
    
- 陪练Agent：交互引导、任务分发与知识讲解
    

订餐Agent是最具挑战的起点，因为：

- 商品品类较少，模型训练容易过拟合
    
- 数据非常脏，用户行为无法用规则精确建模
    
- 用户输入自由度高，但反馈极少
    

这促使我们放弃了传统的“推荐系统三板斧”方案（协同过滤、特征工程+ML、Embedding召回），转向语义规则与状态流驱动的智能体框架。

---

## 二、订餐智能体的核心工程抽象

### 推荐逻辑重构：

- 使用手工构建的语义规则树做推荐候选：例如“想吃辣的”“便宜点的” → 映射到tag组合 → 匹配商品池
    
- 基于意图+tag做推荐路径裁剪（例如“今天天气热想吃凉的” → 冷饮类）
    
- 推荐时考虑库存、用户CDP画像、节日增强等因素（均为配置化）
    

### 有限状态机替代LangGraph：

- 每个用户的对话状态以状态ID维护于Redis（持久化+过期控制）
    
- 状态跳转由语义意图驱动（如：idle → want_food → recommend → cart → confirm）
    
- 状态逻辑自定义可调，便于快速调试与热更新（避免LangGraph的静态结构）
    

### 输入增强：

- 用户输入 = 原始Query + 用户CDP画像 + 天气+节日增强信息 → 构建上下文感知Query
    
- 系统自动扩展“推荐条件提示”与“购物车上下文”
    

### FunctionCall与Chat解耦：

- 意图识别结果会决定是否调用Function工具（如推荐、购物车操作）
    
- 所有工具调用返回结构化结果（中间日志），再通过模板化Prompt进行回复渲染
    
- 实现逻辑分离：感知→意图→决策→调用→渲染，便于组件复用与灰度上线
    

---

### 🧭 状态机为什么不用 LangGraph？——一个工程权衡与未来规划（以及Deerflow的对比参考）

在设计订餐Agent时，我们选择了手工状态机而非LangGraph，主要基于以下考虑：

|   |   |   |
|---|---|---|
|维度|手工状态机（当前方案）|LangGraph|
|状态变迁频繁|✅ 状态结构可热更新（存Redis，便于快速调试）|❌ 状态节点写死于代码，变更需重启|
|状态逻辑复杂度低|✅ 对话流程可图示建模，逻辑透明|⚠ 适合复杂多跳、多Agent任务|
|调试成本|✅ 可直接打印状态切换、意图判断中间日志|⚠ 需要引入LangGraph调试框架|
|多人协作维护|✅ 简单状态表，产品也能参与逻辑配置|❌ 开发主导维护，产品理解门槛高|

> 📌 总结：当前状态机方案更贴近“配置驱动”的理念，便于快速迭代、业务调优、团队协作。

但我们也认识到 LangGraph 在以下场景具有明显优势：

- 多Agent协作：Planner → Executor → MemoryAgent 等串联任务
    
- 工具链嵌套执行：一个动作调用多个子工具，状态依赖复杂
    
- 任务流统一监控与失败恢复机制（Checkpoints）
    

因此，我们已预留状态封装结构（状态名、跳转条件、动作函数分离），未来可平滑迁移至LangGraph。

此外，我们观察到在部分开源项目中（如 Deerflow），LangGraph 被有效用于以下几类任务流：

- 每个任务节点需组合多个动作（如：文档解析 + 切片 + 向量生成 + 入库）
    
- 各节点依赖严格、有状态（需捕获失败、做回滚、依赖前置完成）
    
- 多工具并发调用后需做汇总整合（如：多个文档搜索 → 汇总结果 → 格式化）
    
- Agent行为复杂度高，需长期维护、多人协作参与建模
    

> ✅ 结论建议：LangGraph更适用于高复杂度、链路稳定性要求高、需图形化监控的Agent系统；若任务流程较轻、变化频繁或偏业务规则驱动，自定义状态机方案（或者用轻量级的框架，pydantic ai就不错）反而更灵活、响应更快。

---

## 三、模块化落地经验总结

1. Prompt模块
    
    1. 提供“对话风格Prompt”与“功能型Prompt”分离
        
    2. 多轮对话模板管理，用户语气分析后可动态切Prompt风格
        
2. Tool模块
    
    1. 所有Tool封装为独立异步任务（例如place_order、recommend_products）
        
    2. Tool输入统一Schema，输出有状态码与可视化结构
        
3. Memory模块
    
    1. Redis中记录用户短期行为（当前购物车、最近一次推荐）
        
    2. 按Session与UserID两层结构管理
        
4. Agent内部状态管理
    
    1. 非LangGraph，而是以纯Python手搓状态机（状态→条件→跳转），增强灵活性
        
    2. 兼容链式执行结构，可组合执行多个功能性工具
        
5. 日志与调试体系
    
    1. Tool调用链条标准格式化（含响应时间、异常捕捉）
        
    2. 每轮对话以MessageID为主键全链路追踪（可用于恢复现场）
        

---

## 四、演化展望：Agent平台化的基础图谱

### MCP与A2A的工程化思考（兼容性 vs 适配性权衡）

最近，Google 发布的 A2A（Agent-to-Agent）协议，以及 Anthropic 主导的 MCP（Model Context Protocol）引起了业界广泛关注。它们被视为构建大型智能体系统的基石，预示着“智能体互联网”的未来雏形。然而，站在企业级系统工程的角度审视，它们是否真的适合当前阶段的大多数企业落地？我们结合原理和自身实践，进行了如下拆解：

随着智能体的数量和协作复杂度上升，行业中出现了类似MCP（Model Control Protocol）这样的中立调度协议，意在支持“多Agent-多工具”的平台级接入方式。

我们对其进行了深度调研并小规模接入测试后认为：

> ✅ MCP适合那些**工具种类多、调用链复杂、通用性强的AI平台**，但在垂直业务系统中存在过度抽象、上下文缺失、性能成本高等问题。

因此我们团队选择“兼容MCP协议格式”，但不强依赖它做全链路调度。

以下是我们在设计与MCP/A2A兼容性的工程考量：

#### MCP（Model Control Protocol）调度机制（特别适用于跨域集成场景）：

- 将所有工具调用、任务调度抽象为“工具服务”，通过标准化协议统一管理
    
- 每个Agent只需调用注册在MCP上的工具ID + 参数，不关心工具部署在哪、谁提供
    
- 具备工具发现、参数校验、链式调用、调用日志、权限控制等能力
    
- 工程实现：FastMCP轻量框架 + 注册表 + 异步Task Bus
    

> MCP让Agent变得更轻，但同时也引入了通用协议适配的“最低公共能力”限制，部分业务上下文（如用户画像、商品标签等）很难原地复用，需额外传参或转译。我们目前仅在跨Agent评测、自动工具发现、BI数据工具接入等轻交互或跨域集成场景中尝试MCP格式注册，例如：

- 通过MCP接入由数据平台团队开发的BI工具（报表分析、查询推荐）
    
- 跨业务域的Agent共享统一图谱检索工具
    

但在业务紧耦合、上下文依赖强的核心任务链上，仍坚持使用原生工具路由机制。

我们对 MCP 和 A2A 的态度总结为：

- ✅ 它们是未来“Agent操作系统”的基础构件
    
- ❗ 但企业当前更需要的是：工程可控性、上下文绑定能力、性能稳定性
    

🔧 所以我们的落地建议是：

1. 将 Agent 封装为“工程函数组件”，可调、可测、可追踪；
    
2. 统一调度器（状态机 / 事件流 / FastMCP）管理调用关系；
    
3. 热点 Agent（如订餐服务）服务化部署 + 注册为 MCP Client；
    
4. 热点工具服务注册为 MCP-Service，其它保留本地函数形态。
    

这种混合部署结构兼顾性能、灵活性与未来演化空间。

#### 协议原理简述：A2A（Agent-to-Agent）协作能力：

A2A 使用 HTTP + SSE + JSON-RPC 实现智能体之间异步协作，它规范了：

- 如何描述 Agent 能力（AgentCard）
    
- 如何分发任务（send / sendSubscribe）
    
- 如何流式返回消息或工件（Artifact）
    
- 如何处理长期任务、用户输入等待、交互补充等状态
    

通过这些标准，A2A 让多个智能体可以协同处理多轮任务，甚至支持多模态（文本、音频、视频）交流。

##### 我们的观察与判断：

- A2A 擅长处理“非结构化长任务”，如：用户对话 → 衍生子任务 → 多Agent协作完成回复
    
- 但不适合企业主链路：
    
    - 调用链复杂、状态追踪困难
        
    - Agent可用性未必稳定、无负载治理机制
        
    - 与企业中“请求-响应-写库”式流程逻辑冲突
        

> ✅ 更适合放在开放平台、交互式助手系统中，处理非结构化协同任务。

- 支持Agent之间以任务流方式传递数据/意图/控制权
    
- A2A可以通过共享消息队列或事件中枢（EventBus）实现
    
- 我们支持：Agent发出一个目标状态，另一个Agent作为工具响应
    
- 工程实践中，A2A调用通过MCP转译为“工具调用”，便于日志追踪与权限审计
    

> A2A让系统具备“多智能体生态”的雏形，为AI World搭建基础通讯能力。

---

- 所有Agent共享的组件：
    
    - 工具层（如：知识库查询、商品推荐）
        
    - 状态管理框架（支持插件化状态迁移）
        
    - 日志追踪与成本分析系统
        
- 探索AI World方向：支持Agent注册身份、能力、记忆、偏好
    
- Agent调度与注册中心（MCP-like架构）：统一入口、统一调度、多Agent任务协作
    

---

## 五、实战示例：代码与开源项目拆解

### ✅ FastMCP 工具注册实战代码

以订餐Agent中“推荐商品”为例，我们将规则推荐逻辑封装为一个 MCP Tool：

```Python
from fastmcp import FastMCP
mcp = FastMCP(agent_name="DiningAgent")
@mcp.tool(name="recommend_products", description="根据用户偏好推荐商品")
async def recommend_products(category: str = '', spicy: str = '') -> list:
    rules = load_rules()  # 加载规则树
    matched = match_items(rules, category, spicy)
    return [{"name": i.name, "price": i.price} for i in matched]
```

- 所有工具具备标准Schema输入输出，可被MCP Client统一发现和调用
    
- 我们使用FastMCP + pydantic进行输入验证、权限标注、调用链追踪
    
- 工具调用日志：含trace_id、耗时、入参、异常等元数据
    

---

### 🔍 开源项目分析：Deerflow 中的 LangGraph 构建

Deerflow 是一个将 LangGraph 作为核心任务流编排引擎的智能体框架，推荐重点关注它的两个部分：

#### 1）任务链编排方式：

```Python
from langgraph.graph import StateGraph
graph = StateGraph()
graph.add_node("rewrite_query", QueryRewriteNode())
graph.add_node("retrieve", HybridSearchNode())
graph.add_node("answer", AnswerNode())
graph.set_entry_node("rewrite_query")
graph.add_edge("rewrite_query", "retrieve")
graph.add_edge("retrieve", "answer")
```

- 每个节点封装独立功能（如 query 改写、向量检索、答案生成）
    
- 可插入中间错误处理、状态检查、Token预算限制等
    
- 所有任务状态可视化追踪，适合需要精细控制的Agent系统
    

#### 2）适用场景

- 多轮状态流：嵌套工具调用、复杂路径跳转
    
- 多Agent协作：节点之间可独立运行、部署
    
- 调度容错要求高的RAG系统、辅助工具链路（如“文档 → QA片段 → 问答Agent”）
    

---

## 六、演讲核心要讲什么？我们聚焦五件事

> 面向后端、算法、产品同学，我们希望大家听完之后，对“工程化Agent到底是什么”有共识，对我们是怎么落地的有理解。

### ① 我们为什么要自建Agent系统？

- 模型很好，但不是系统；Prompt很强，但不够管控。
    
- 从订餐Agent实战讲起，模型效果不如规则 → 我们用语义规则+状态流 → 推出了“能跑起来”的订餐体验。
    

### ② Agent到底是什么？不是Prompt堆，而是任务执行单元

- Prompt + Tool + 状态 + 记忆 + 渲染
    
- 每个Agent像一个“具备输入输出”的微应用，可以组合、拆分、重用
    

### ③ LangGraph我们为什么没用？但有没有可能以后用？

- 我们状态轻、变化快、调试密 → 自定义状态机更灵活
    
- LangGraph适合“复杂大Agent系统”：结构清晰、稳定迭代少、多人维护
    
- 所以我们“设计上兼容，部署上延后”，不急于重框架
    

### ④ MCP / A2A我们怎么看？适合什么、不适合什么？

- MCP 是“标准化工具调用”，A2A 是“Agent之间通信”
    
- 企业落地：MCP 适合跨域工具集成（如BI），不适合强上下文主链；A2A适合开放平台，不适合业务核心流转
    
- 我们的选择：Agent模块化 + 热点服务MCP化 + 工具做MCP-Service
    

### ⑤ 工程建议：Agent系统要“模块化先于服务化”

- 每个Agent都像函数，可以局部调试、组合复用、成本可控
    
- 真正流量大、协作多的Agent再服务化（如订餐Agent），注册成MCP客户端
    

---

## 七、结语

从订餐Agent起步，我们并没有直接使用LangChain或LangGraph，而是基于问题场景构建了自己的可控框架：以语义规则、手工状态流、配置化工具组为核心。智能体不是堆Prompt，而是一个系统性工程。

我们相信：Agent最终将演变为一种业务逻辑的可配置表达方式——而你现在看到的，只是这个系统生态的起点。