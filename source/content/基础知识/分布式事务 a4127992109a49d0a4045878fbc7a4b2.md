# 分布式事务

Owner: yancy yu

## **分布式事务**

分布式事务就是指事务的发起者、资源及资源管理器和事务协调者分别位于分布式系统的不同节点之上。

分布式事务--两阶段提交（2PC）

**准备阶段：**协调者询问参与者事务是否执行成功，参与者发回事务执行结果

![Untitled](Untitled%202.jpeg)

**提交阶段：**如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务

![Untitled](Untitled%203.jpeg)

**问题：**

1.同步阻塞： 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。

2.单点问题：协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。

3.数据不一致：在阶段二，如果只有部分参与者提交了事务，使得系统数据不一致。

4.太过保守：任意一个节点失败就会导致整个事务失败，没有完善的容错机制。

## 分布式事务--TCC（Try-Confirm-Cancel）

TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：

1.Try 阶段主要是对业务系统做检测及资源预留

2.Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：**只要Try成功，Confirm一定成功。**

3.Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。

**优点：** 跟2PC比起来，实现以及流程相对简单了一些

**缺点：** 在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，实现的时候多写很多补偿的代码

分布式事务--本地消息表

![Untitled](Untitled%204.jpeg)

会有一张存放本地消息的表，然后在执行业务的时候 将业务的执行和将消息放入消息表中的操作**放在同一个事务中**，这样就能保证消息放入本地表中业务肯定是执行成功的。

然后再去调用下一个操作，如果下一个操作调用成功了好说，消息表的消息状态可以直接改成已成功。

如果调用失败，后台任务定时去读取本地消息表，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。

这时候有可能消息对应的操作不成功，因此也需要重试，重试就得保证对应服务的方法是幂等的，而且一般重试会有最大次数，超过最大次数可以记录下告警让人工处理。

可以看到本地消息表其实实现的是最终一致性。

## 分布式事务--消息事务

RocketMQ 就很好的支持了消息事务，让我们来看一下如何通过消息实现事务。

1.给 Broker 发送事务消息即半消息，半消息不是说一半消息，而是这个消息对消费者来说不可见，然后发送成功后发送方再执行本地事务。

2.根据本地事务的结果向 Broker 发送 Commit 或者 RollBack 命令。

并且 RocketMQ 的发送方会提供一个反查事务状态接口，如果一段时间内半消息没有收到任何操作请求，那么 Broker 会通过反查接口得知发送方事务是否执行成功，然后执行 Commit 或者 RollBack 命令。

如果是 Commit 那么订阅方就能收到这条消息，然后再做对应的操作，做完了之后再消费这条消息即可。

如果是 RollBack 那么订阅方收不到这条消息，等于事务就没执行过。

RocketMQ 提供了事务消息的功能，我们只需要定义好事务反查接口即可。

什么是最大努力通知（Try Best Nofity）？

其实我觉得本地消息表也可以算最大努力，事务消息也可以算最大努力。

就本地消息表来说会有后台任务定时去查看未完成的消息，然后去调用对应的服务，当一个消息多次调用都失败的时候可以记录下然后引入人工，或者直接舍弃。这其实算是最大努力了。

事务消息也是一样，当半消息被commit了之后确实就是普通消息了，如果订阅者一直不消费或者消费不了则会一直重试，到最后进入死信队列。其实这也算最大努力。

所以最大努力通知其实只是表明了一种柔性事务的思想：我已经尽力我最大的努力想达成事务的最终一致了。

适用于对时间不敏感的业务，例如短信通知。

## TDXA-分布式事务引擎

通过引入分布式事务管理器（Transaction Manager），将全局事务分解为多个子事务，并交给不同的资源管理器（Resource Manager）处理。同时，针对不同的资源类型抽象为不同的事务处理模型，帮助业务实现自动的事务提交或回滚。面对复杂的长事务流程，业务可以自定义组合不同的事务模型，并根据业务自身特点指定不同的异常处理策略（Error Strategies），让业务开发像处理单机事务一样来保证整体分布式事务的一致性。通过这样的方法，可以有效地帮助业务开发减少异常处理，更专心地实现业务核心逻辑。TDXA目前支持TCC事务范式、DB事务范式、TRY_BEST事务范式

约束：

TRY_BEST和TCC两种模式调用的RPC接口需要保证幂等。

三种模式支持混合使用，但是需要保证调用顺序，最佳实践是优先执行可以回滚的操作。

![Untitled](Untitled%2024.png)

## 自动异常处理：Pulsar（云原生的消息和流存储的平台）

状态机的流程管理：由于计费流程的复杂性，通常一笔完整的支付请求需要至少几十次的rpc调用。我们希望加强对流程的约束管理以减少可能的逻辑错误。我们的主要解决思路是，通过状态图定义服务调用流程，基于事件进行驱动来完成整个流程。其中，每个节点表示一个rpc操作，每个rpc操作分为三个独立过程（Pre/RPC/Post）；每条边上可以定义多个算子，通过算子的返回值实现服务路由。

业务开发只需要关心业务节点注册的Pre和Post回调接口的具体实现，以及每个业务节点操作结果的返回算子，其余工作由框架完成整个流程的驱动，以及分布式事务的提交或回滚