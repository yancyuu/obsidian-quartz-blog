

## 三次握手

三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段

![Untitled](Untitled%205.jpeg)

ACK，SYN是标志位

Ack是数据包(ACK_NUM)

客户端：序列号=x=0； ACK NUM = 0; SYN=1(第一步)  —→ 服务器

![Untitled](Untitled%2025.png)

服务器：序列号：y=0；ACK_NUM = x +1=1 ；ACK=1，SYN=1 （确认+请求） —→客户端

![Untitled](Untitled%2026.png)

客户端：序列号：x+1；ACK_NUM = y +1=1 ；ACK=1 确认 —→服务器

![Untitled](Untitled%2027.png)

### 如果三次握手的时候每次握手信息对方没有收到会怎么样？

ACK：这里出现的ACK即为上面所说的TCP报文段首部中的“ACK字段”，置1时该报文段为确认报文段。

ack：而ack则为TCP报文段首部中“确认号字段”的具体数值。

**第一次握手（syn包）丢失**

当客户端发起的 TCP 第一次握手 SYN 包，在超时时间内没收到服务端的 ACK，就会超时重传 SYN 数据包，（每次超时重传的 RTO 是翻倍上涨的，最大次数tcp_syn_retries默认5）。

<aside>
🚧 RTO（Retransmission Timeout）是重传超时时间，是 TCP 协议中一个非常重要的概念。当 TCP 发送一个数据段后，它会启动一个定时器，该定时器的超时时间就是 RTO。如果在 RTO 时间内没有收到接收方的确认（ACK），TCP 会认为该数据段可能已经丢失，然后会重新发送这个数据段。

</aside>

**第二次握手（ack+syn包）丢失**

当 TCP 第二次握手 SYN、ACK 包丢了后，**客户端第一次握手的SYN 包会发生超时重传，服务端第二次握手的SYN、ACK 也会发生超时重传**。

服务端 SYN、ACK 包时重传的最大次数，是由 tcp_synack_retries 决定的，默认5。

**第三次握手（ack包）丢失**

### 对于服务器：

在建立 TCP 连接时，如果第三次握手的 ACK，服务端无法收到，则服务端就会短暂处于 SYN_RECV 状态，而客户端会处于 ESTABLISHED 状态。

一旦连接进入 **`ESTABLISHED`** 状态，两个端点就可以开始双向数据传输。这意味着不仅客户端可以发送数据给服务器，服务器也可以发送数据给客户端。

由于服务端一直收不到 TCP 第三次握手的 ACK，**则第二次握手客户端会一直重传 SYN、ACK 包**，直到重传次数超过 tcp_synack_retries 值（默认5 ）后，服务端就会断开 TCP 连接。 （**这里的断开是服务器单方面主动断开，客户端的状态还是established的**）

### 对于客户端：

情况1：如果客户端没发送数据包，一直处于 ESTABLISHED 状态，触发保活机制检查这个tcp连接是否还存活，如果不存活，则为死亡连接，客户端断开连接。 （触发保活机制）

情况2：如果客户端发送了数据包，一直没有收到服务端对该数据包的确认报文，则会一直重传该数据包，直到重传次数超过 tcp_retries2 值（默认15 ）后，客户端就会断开 TCP 连接。

### 为什么三次

### 核心原因：避免重复链接

**比如在网络环境比较复杂的情况，客户端可能会连续发送多次请求。如果只设计成两次握手的情况，服务端只能一直接收请求，然后返回请求信息，也不知道客户端是否请求成功。这些过期请求的话就会造成网络连接的混乱。**

保证双方都是双工通信

第一次握手,服务端确定客户端的发送正常

第二次握手,客户端确认服务端的收发正常

第三次握手,服务端确定客服端接收正常

## 四次挥手：

四次挥手即 TCP 连接的释放，这里假设客户端主动释放连接在挥手之前主动释放连接的客户端结束 ESTABLISHED 阶段，随后开始四次挥手

ACK，FIN是标志位

![Untitled](Untitled%2028.png)

### 为什么四次

因为TCP是全双工的，两个方向的连接需要单独关闭。举例：因为B收到A要结束的请求后，还要把没有说完的话发完，等B把要说的话说完后B才发回一个结束FIN数据。

**当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文**。**所以客户端在发送完 ACK 确认报文之后，会设置一个时长为 2 MSL 的计时器**。MSL（Maximum Segment Lifetime），指一段 TCP 报文在传输过程中的最大生命周期。2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长。

### **TIME-WAIT** 为什么是 2MSL

若服务器在 1 MSL 内没有收到客户端发出的 ACK 确认报文，会再次向客户端发出 FIN 报文。

如果客户端在 2 MSL 内收到了服务器再次发来的 FIN 报文，说明服务器由于一些原因并没有收到客户端发出的 ACK 确认报文。客户端将再次向服务器发出 ACK 确认报文，并重新开始 2 MSL 的计时。

**若客户端在 2MSL 内没有再次收到服务器发送的 FIN 报文，则说明服务器正常接收到客户端 ACK 确认报文，客户端可以进入 CLOSE 阶段，即完成四次挥手。**

**客户端要经历 2 MSL 时长的 TIME-WAIT 阶段，为的是确认服务器能否接收到客户端发出的 ACK 确认报文。**

### TCP 是如何保证可靠性的

- **数据分块：**应用数据被分割成 TCP 认为最适合发送的数据块。
- **序列号和确认应答：**TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。
- **校验和：** TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。
- **流量控制：** TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。
- **拥塞控制：** 当网络某个节点发生拥塞时，减少数据的发送。
- **ARQ（自动重传）**协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
- **超时重传：** 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。

### TCP滑动窗口算法

> 数据在传输时，TCP会对所有数据进行编号，发送方在发送过程中始终保持着一个窗口，只有落在发送窗口内的数据帧才允许被发送；同时接收方也始终保持着一个接收窗口，只有落在窗口内的数据才会被接收。这样通过改变发送窗口和接收窗口的大小就可以实现流量控制。
> 

TCP有两个滑动窗口，一个用于接收数据，一个用于发送数据。接收方设备要求窗口大小为0时，表明接收方已经接收了全部数据，或者接收方应用程序没有时间读取数据，要求暂停发送。

**发送端丢包：**

![Untitled](Untitled%206.jpeg)

当某一段报文丢失了，图中（1001-2000）数据段丢失了，接收方没有接收到该数据段，则会一直给发送端发送ACK（下一个是1001），如果发送端连续收到同样的ACK（下一个是1001），就会将对应的（1001-2000）重新发送，这时候如果接收端收到1001后，再次返回的就是ACK（7001）。这种机制被称为快速重传

### TCP 流量控制与拥塞控制

1. **流量控制**
    
    所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。如果接收方来不及接收发送方发送的数据，那么就会有分组丢失。在 TCP 中利用可变长的滑动窗口机制可以很方便的在 TCP 连接上实现对发送方的流量控制。主要的方式是接收方返回的 ACK 中会包含自己的接收窗口大小，以控制发送方此次发送的数据量大小（发送窗口大小）。
    
2. **拥塞控制**
    
    在实际的网络通信系统中，除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：**慢开始和拥塞避免、快重传和快恢复。**
    
3. **拥塞控制和流量控制的区别**
    
    拥塞控制往往是一种全局的，防止过多的数据注入到网络之中，而TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处，因此，流量控制往往指点对点通信量的控制，是端到端的问题。
    
4. **如果接收方滑动窗口满了，发送方会怎么做**
    
    此时接收方返回给发送方的接收窗口大小为 0，此时发送方会等待接收方发送的窗口大小直到变为非 0 为止，然而，接收方回应的 ACK 包是存在丢失的可能的，为了防止双方一直等待而出现死锁情况，此时就需要坚持计时器来辅助发送方周期性地向接收方查询，以便发现窗口是否变大。