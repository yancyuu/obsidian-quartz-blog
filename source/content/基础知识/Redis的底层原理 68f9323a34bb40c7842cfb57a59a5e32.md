# Redis的底层原理

Owner: yancy yu

Redis是一个高性能的开源键值存储系统，它的底层原理和数据结构非常精巧，以下是一些关键概念和原理：

是的，**Redis通常被称为单进程应用程序，因为它使用单线程来处理命令请求**。这意味着在任何时刻，Redis只会执行一个命令，而不会并发执行多个命令。这个单线程模型是Redis的一个关键特点。

尽管Redis的主要执行线程是单线程，但它使用了事件驱动的方式来实现高并发。通过事件驱动，Redis能够同时处理多个客户端连接，而不需要为每个连接创建一个独立的线程。这使得Redis在处理大量客户端请求时能够保持高性能和低资源消耗。

Redis之所以选择单线程模型，是为了避免多线程编程中常见的竞态条件和锁的开销，从而提高了操作的响应速度和可维护性。尤其对于读取密集型的操作，单线程模型在性能上非常高效。

需要注意的是，虽然Redis的主线程是单线程的，但Redis并不是完全单一的，它可以配置成主从复制集群，其中主节点和从节点之间会有数据复制的多线程操作，但主节点的主要请求处理仍然是单线程的。

## **内存数据库**：

Redis将数据存储在内存中，因此读取和写入非常快速。数据可以持久化到磁盘，以防止数据丢失。

Redis的数据存储在内存中，这意味着所有的数据都在RAM中，因此读取和写入非常快。Redis通过将数据持久化到磁盘来确保数据不会因服务器重启而丢失。Redis支持两种持久化方式：[RDB快照和AOF日志](%E6%8C%81%E4%B9%85%E5%8C%96RDB%EF%BC%8CAOF%202abfdff5ee25437a9411330d4572a5c8.md)。RDB定期将内存中的数据快照保存到磁盘，而AOF将每个写操作追加到日志文件中，可以根据需要选择合适的方式。

## **单线程模型**：

Redis采用单线程模型来处理命令请求。这意味着Redis在任何时刻只处理一个命令，避免了多线程的竞态条件和锁的开销。单线程模型对于读取密集型和简单写入操作非常高效。对于读取（IO）密集型的操作，Redis的单线程模型非常高效，因为它无需处理复杂的并发控制。

## **事件驱动**

Redis使用事件驱动的方式来处理客户端请求和网络通信。它采用了事件循环（Event Loop）来监听套接字，当有请求到来时，会执行相应的操作。这种非阻塞的事件驱动模型允许Redis同时处理多个客户端连接，而不需要为每个连接创建一个线程。

## **数据结构**

Redis支持多种数据结构，包括[字符串](SDS%200970091699f64780b864332ae5349fcc.md)、列表、集合、有序集合、散列等。这些数据结构在底层都经过高度优化，以提供高性能和低内存消耗。例如，Redis的列表数据结构被实现为一个双向链表，它可以快速执行从头部或尾部插入和删除元素的操作。

Redis（Remote Dictionary Server）是一个高性能的键值存储系统，它支持多种复杂的数据结构，包括字符串、列表、集合、有序集合和散列（哈希）。在这里，我会简要介绍Redis支持的几种主要的底层数据结构：

### 1. 字符串（String）

在底层，Redis的字符串使用简单的[动态字符串（SDS, Simple Dynamic String）](SDS%200970091699f64780b864332ae5349fcc.md)来实现。SDS除了存储实际的字符数组外，还保存了长度和容量信息，这样可以快速进行长度计算和重新分配操作。

### 2. 列表（List）

Redis的列表数据结构主要有两种实现方式：双向链表和压缩列表（ziplist）。

- **双向链表**：每个节点包含值和两个指向前后节点的指针。这样可以快速地从列表的头部或尾部插入或删除元素。
- **压缩列表**：用于存储小的和有限数量的元素。压缩列表在内存使用方面更有效，但它不如双向链表操作灵活。

### 3. 集合（Set）

集合在Redis中主要有两种底层实现：

- **整数集合（IntSet）**：用于存储小范围的整数值，以非常紧凑和高效的二进制方式。
- **哈希表**：用于存储更通用和大规模的数据。

### 4. 有序集合（Sorted Set）

有序集合的底层实现主要有两种：跳跃列表（Skip List）和ziplist。跳跃列表用于存储大量元素，而ziplist用于小规模数据。

- **跳表**
    
    跳表（Skip List）是一种用于快速查找的数据结构，特别适用于有序的序列。跳表通过维护多级索引来实现快速查找，从而达到平均 \(O(\log n)\) 的查找时间复杂度。它是一种可以用来代替平衡二叉树的数据结构。
    
    **结构**
    
    1. **基础层**：底层是一个普通的有序链表，包含所有的元素。
    2. **索引层**：在基础层之上有多个索引层。第 \(i\) 层的索引节点包含第 \(i-1\) 层中的部分或全部节点。最高层的索引只包含几个节点。
    
    一个简单的跳表可能看起来像这样（箭头表示节点的指针）：
    
    ```
    Level 3:       17 ------------------------> 39 -----> 47
    Level 2:       17 ----------> 25 ----------> 39 -----> 47
    Level 1:       17 ----> 20 -> 25 -----> 31 -> 39 -----> 47
    Base Level:    17 -> 19 -> 20 -> 21 -> 25 -> 28 -> 31 -> 39 -> 40 -> 47
    
    ```
    
    **查找操作**
    
    1. **开始于最高层**：查找操作从最高层的第一个节点开始。
    2. **水平移动**：如果目标值大于当前节点的下一个节点的值，则向右（水平）移动。
    3. **垂直移动**：如果目标值小于或等于当前节点的下一个节点的值，则向下（垂直）移动到下一层。
    4. **到达底层**：当到达底层时，如果存在一个节点的值等于目标值，则查找成功。
    
    **插入操作**
    
    1. **查找插入点**：和查找操作类似，我们先找到在基础层中应当插入的位置。
    2. **随机层数**：随机生成一个数，决定新节点应该“穿越”多少层。
    3. **插入节点**：在相应的层中插入新节点，并更新指针。
    
    **时间复杂性**
    
    - 查找、插入、删除操作的平均和最坏情况时间复杂性都是 \(O(\log n)\)。
    
    跳表相较于平衡二叉树来说，更易于实现，并且在实际应用中，例如在 Redis 的有序集合中，跳表被用作主要的数据结构。希望这次解释能让你对跳表有更清晰的理解。
    

### 5. 散列（Hash）

Redis的哈希数据结构也有两种底层实现方式：ziplist和哈希表。

- **ziplist**：用于存储小规模的键值对。
- **哈希表**：用于存储大规模数据。

### 6. Bitmaps 和 HyperLogLogs

这些数据结构是使用字符串的特殊编码实现的。

### 7. Geospatial Indexes

地理空间索引使用有序集合和特殊的编码算法来存储和查询地理位置数据。

这些底层数据结构的选择和转换通常是自动进行的，以便根据使用情况优化性能和内存使用。

希望这个简要的介绍能帮助你更好地理解Redis的底层数据结构。如果你有更多问题或需要进一步的解释，请随时问。

## [**持久化**](%E6%8C%81%E4%B9%85%E5%8C%96RDB%EF%BC%8CAOF%202abfdff5ee25437a9411330d4572a5c8.md)

Redis支持两种主要的持久化方式：RDB快照和AOF日志。RDB会周期性地将内存中的数据快照保存到磁盘，而AOF会将每个写操作追加到日志文件中。这两种方式可以根据需要选择，用于数据的恢复和备份。**RDB持久化会定期将内存中的数据快照保存到磁盘文件中**，以便在服务器重启时恢复数据。**AOF持久化将每个写操作追加到一个日志文件中**，当服务器启动时，可以重新执行这些写操作以恢复数据。这两种方式可以根据需求配置，或者同时启用。

**LRU淘汰策略**

当Redis的内存不足时，它使用LRU（Least Recently Used，最近最少使用）算法来淘汰不常用的数据。LRU策略会选择最近最久没有被访问过的数据进行淘汰，以释放内存空间。

**分布式特性**

Redis可以配置成一个主从复制的集群，这意味着一个主节点可以拥有多个从节点，从节点复制主节点的数据。这提供了数据的备份和高可用性。Redis还支持分片（Sharding）以分散数据负载到多个节点，从而提高了性能和扩展性。

**事务支持**

Redis支持事务，可以通过MULTI和EXEC命令来执行一系列操作，保证这些操作的原子性。这意味着在事务执行期间，其他客户端不会干扰这个事务的操作，要么全部执行，要么全部回滚，确保数据的一致性。